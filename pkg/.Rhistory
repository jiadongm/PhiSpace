use_r("CVTune_ncomp") # Internal
use_r("CVTune_nfeat") # Internal
use_r("getErr") # Internal
use_r("getErr_nfeat")
# Check and compiel package
# test()
document()
install()
library(devtools)
## Commit
# use_git()
# use_github()
document()
check()
install()
library(devtools)
# Attach all defined functions
load_all()
use_r("PhiSpaceR_1ref")
install()
library(devtools)
# Attach all defined functions
load_all()
use_r("PhiSpaceR_1ref")
library(devtools)
# Attach all defined functions
load_all()
?PhiSpace_1ref
?PhiSpace_1ref
?getClass
PhiSpace::PhiSpaceR_1ref
?PhiSpace::PhiSpace_1ref
use_r("PhiSpaceR_1ref")
?PhiSpaceR_1ref
# Check and compiel package
# test()
document()
check()
git push
install.packages("VennDiagram")
devtools::check()
library(devtools)
document()
check()
document()
check()
class(list())
foo <- list(c("A", "B"), c("B", "C"))
?intersect
Reduce(intersect, foo)
foo <- list(c("A", "B"), c("B", "C"), c("B", "D"))
Reduce(intersect, foo)
foo <- list(c("A", "B"), c("B", "C"), c("B", "C"))
Reduce(intersect, foo)
foo <- list(c("A", "B"), c("B", "C"), c("A", "C"))
Reduce(intersect, foo)
"A" %in% Reduce(intersect, foo)
load_all()
RankTransf
RankTransf
load_all()
RankTransf
document()
check()
use_r("SuperPC")
document()
check()
SeuratObject:::as.sparse.matrix()
SeuratObject:::as.sparse.matrix
SeuratObject:::as.sparse.Matrix
#' Apply rank transform to a gene by cell matrix.
#'
#' @param X A gene by cell matrix.
#'
#' @return Rank transformed cell by gene matrix.
#'
RTassay <- function(X){
temp <- apply(X, 1, rank, ties.method = "min") - 1
temp <- temp/(nrow(X) - 1)
return(temp)
}
foo
foo <- matrix(rnorm(6),2)
foo
RTassay(foo)
temp <- apply(foo, 1, rank, ties.method = "min") - 1
temp
temp <- apply(foo, 2, rank, ties.method = "min") - 1
temp
temp/(nrow(foo) - 1)
X <- matrix(rnorm(12),4)
temp <- apply(X, 2, rank, ties.method = "min") - 1
temp
X
temp/(nrow(X) - 1)
temp/(nrow(temp) - 1)
X <- PhiSpace:::as.sparse.matrix(X)
X
X <- matrix(c(0,0,1,1,0,1), 3)
X
X <- PhiSpace:::as.sparse.matrix(X)
X
temp <- apply(X, 2, rank, ties.method = "min") - 1
temp
temp <- temp/(nrow(temp) - 1)
temp
library(devtools)
document
document()
check()
??plotUMAP
?getPC
??getPackageName
?PhiSpace::getPC
PhiSpace
devtools::load_all()
?getPC
??set_colnames
??set_colnames
devtools::document()
devtools::check()
devtools::document()
devtools::document()
devtools::check()
?kmeans
?split
query <- scuttle::mockSCE()
query
query$Treatment
clusterid <- "Treatment"
query$Cell_Cycle
phenotypes <- "Cell_Cycle"
library(devtools)
load_all()
sce <- query
## Resampling indices
nGenes <- nrow(sce)
nCells <- ncol(sce)
YY
YY <- codeY(sce, phenotypes)
Y
YY
cluster <- as.character(colData(sce)[, clusterid])
cluname <- sort(unique(cluster))
splited <- split(1:nCells, cluster)
cluname
idxList <- split(1:nCells, cluster)
Ncluster <- length(cluname)
resampSizes = 100
# Index list
cluster <- as.character(colData(sce)[, clusterid])
cluname <- sort(unique(cluster))
idxList <- split(1:nCells, cluster)
names(idxList) <- cluname
Ncluster <- length(cluname)
clustSizes <- sapply(idxList, length)
clustSizes
clustSizes * proportion
proportion = 0.1
ceiling(clustSizes * proportion)
resampSizes <- rep(resampSizes, Ncluster)
resampSizes
ceiling(clustSizes * proportion)
nPool = 15
x=1
clustSize <- clustSizes[x]
resampSizes <- ceiling(clustSizes * proportion)
clustSize <- clustSizes[x]
sample(x, nPool*clustSize, replace = TRUE)
clustSize
resampSize <- resampSizes[x]
resampSize
sample(x, nPool*resampSize, replace = TRUE)
sample(idxList[[x]], nPool*resampSize, replace = TRUE)
resampIdxList <- lapply(
1:Ncluster,
function(x){
resampSize <- resampSizes[x]
sample(idxList[[x]], nPool*resampSize, replace = TRUE)
}
)
resampIdx <- do.call(c, resampIdxList)
resampIdx
resampIdx |> length()
315/15
resampIdx <- lapply(
1:Ncluster,
function(x){
resampSize <- resampSizes[x]
sample(idxList[[x]], nPool*resampSize, replace = TRUE)
}
)
resampIdx <- do.call(c, resampIdx)
?aggregate
resampSizes
totalResampSize <- sum(resampSizes)
totalResampSize
rep(1:totalResampSize, rep(nPool, totalResampSize))
resampSize <- resampSizes[x]
split(
sample(idxList[[x]], nPool*resampSize, replace = TRUE),
rep(1:resampSize, rep(nPool, resampSize))
)
do.call(c, resampIdx)
resampIdx <- lapply(
1:Ncluster,
function(x){
resampSize <- resampSizes[x]
split(
sample(idxList[[x]], nPool*resampSize, replace = TRUE),
rep(1:resampSize, rep(nPool, resampSize))
)
}
)
do.call(c, resampIdx)
?split
resampIdx <- lapply(
1:Ncluster,
function(x){
resampSize <- resampSizes[x]
out <- split(
sample(idxList[[x]], nPool*resampSize, replace = TRUE),
rep(1:resampSize, rep(nPool, resampSize))
)
names(out) <- NULL
return(out)
}
)
resampIdx <- do.call(c, resampIdx)
resampIdx
assayName = "counts"
# Aggregate
XX <- assay(sce, assayName)
XX
dimnames(XX) <- NULL
# Aggregate
XX <- assay(sce, assayName)
# Aggregate
XX <- assay(sce, assayName)
colnames(XX) <- NULL
XX
x <- resampIdx[[1]]
x
XX[,x]
rowMeans(XX[,x])
# Aggregate
XX <- assay(sce, assayName)
rowMeans(XX[,x])
dim(XX)
# Aggregate
XX <- assay(sce, assayName)
XXagg <- sapply(
resampIdx,
function(x){
rowMeans(XX[,x])
}
)
XXagg
YYagg <- sapply(
resampIdx,
function(x){
colMeans(YY[x,])
}
)
YYagg
YYagg <- t(
sapply(
resampIdx,
function(x){
colMeans(YY[x,])
}
)
)
YYagg
clusterid = "Cell_Cycle"
phenotypes
YY <- codeY(sce, phenotypes)
if(is.null(clusterid)) clusterid <- phenotypes[1]
YY
## Resampling indices
nGenes <- nrow(sce)
nCells <- ncol(sce)
# Index list
cluster <- as.character(colData(sce)[, clusterid])
cluname <- sort(unique(cluster))
idxList <- split(1:nCells, cluster)
names(idxList) <- cluname
Ncluster <- length(cluname)
clustSizes <- sapply(idxList, length)
# How many to resample
if(is.null(proportion)){
if(length(resampSizes) == 1){
resampSizes <- rep(resampSizes, Ncluster)
} else {
if(length(resampSizes) != Ncluster) stop("Length of resampSizes has to be either 1 or number of clusters.")
}
} else {
resampSizes <- ceiling(clustSizes * proportion)
}
resampIdx <- lapply(
1:Ncluster,
function(x){
resampSize <- resampSizes[x]
out <- split(
sample(idxList[[x]], nPool*resampSize, replace = TRUE),
rep(1:resampSize, rep(nPool, resampSize))
)
names(out) <- NULL
return(out)
}
)
resampIdx <- do.call(c, resampIdx)
# Aggregate
XX <- assay(sce, assayName)
XXagg <- sapply(
resampIdx,
function(x){
rowMeans(XX[,x])
}
)
YYagg <- t(
sapply(
resampIdx,
function(x){
colMeans(YY[x,])
}
)
)
YYagg
resampIdx
ceiling(clustSizes * proportion)
colnames(XXagg) <- paste0("PB", 1:ncol(XXagg))
XXagg
sce <- SingleCellExperiment()
sce
targetAssayName <- "data"
assay(sce, targetAssayName) <- XXagg
# Output
sce <- SingleCellExperiment(
list(data = XXagg)
)
YYagg
colnames(XXagg) <- rownames(YYagg) <- paste0("PB", 1:ncol(XXagg))
# Output
sce <- SingleCellExperiment(
list(data = XXagg),
colData = YYagg
)
sce
sce@colData
document()
check()
?scran::quickCluster
?reducedDim
?SingleCellExperiment
?irlba::irlba
set.seed(1)
A <- matrix(runif(400), nrow=20)
S <- irlba(A, 3)
library(irlba)
set.seed(1)
A <- matrix(runif(400), nrow=20)
S <- irlba(A, 3)
T <- rARPACK::svds(A, 3)
S$d
T$d
?svdr
?ssvd
?irlba::prcomp_irlba
irlba::prcomp_irlba
set.seed(1)
A <- matrix(rnorm(20000*20000), nrow=20000)
A <- matrix(rnorm(20000*2000), nrow=20000)
tik <- Sys.time()
foo <- rARPACK::svds(A, 30)
Sys.time() - tik
tik <- Sys.time()
foo <- irlba::irlba(A, 30)
Sys.time() - tik
vec <- rnorm(20000*2000)
vec[sample(1:length(vec), length(vec)*0.7)] <- 0
A <- matrix(, nrow=20000)
A_sp <- Matrix::Matrix(A, sparse = T)
A
vec <- rnorm(20000*2000)
vec[sample(1:length(vec), length(vec)*0.7)] <- 0
vec
A <- matrix(vec, nrow=20000)
A_sp <- Matrix::Matrix(A, sparse = T)
A
A[1:10,1:10]
A_sp <- Matrix::Matrix(A, sparse = T)
?Matrix::Matrix
library(Matrix)
A_sp <- Matrix(vec, 20000, sparse = T)
A_sp <- Matrix(vec, 20000, 2000, sparse = T)
A_sp <- Matrix(vec, 20000, 2000, sparse = TRUE)
A_sp
foo <- rARPACK::svds(A_sp, 30)
B <- A_sp[1:5,1:5]
B
scale(B)
scale(B, F, F)
scale(B, F, F) |> Matrix(sparse=TRUE)
foo <- svd(B)
foo$u
foo$v
colSums(B)
load_all()
getPC(B)
getPC(B, 2)
getPC(B, 2, sparse = T)
getPC(B, 2, sparse = TRUE)
B
getPC(B, 2, center = F, sparse = TRUE)
load_all()
getPC(B, 2, center = F, sparse = TRUE)
X <- B
X
ncomp = 2
huhn <- suppressWarnings(rARPACK::svds(X, k = ncomp))
D <- huhn$d[1:ncomp]
scores <- Matrix(
huhn$u[, 1:ncomp, drop = FALSE] %*% diag(D, nrow = ncomp),
sparse = sparse
)
loadings <- Matrix(
huhn$v[, 1:ncomp, drop = FALSE],
sparse = sparse
)
huhn$u[, 1:ncomp, drop = FALSE] %*% diag(D, nrow = ncomp)
huhn$v
?rARPACK::svds
scale(B, F, F)
huhn <- suppressWarnings(rARPACK::svds(X, k = ncomp))
D <- huhn$d[1:ncomp]
huhn$u[, 1:ncomp, drop = FALSE]
huhn$u[:, 1:ncomp, drop = FALSE]
leftSing <- huhn$u[, 1:ncomp, drop = FALSE]
leftSing[leftSing < 1e-10]
leftSing[leftSing < 1e-10] <- 0
leftSing
sparse = TRUE
scores <- Matrix(
leftSing %*% diag(D, nrow = ncomp),
sparse = sparse
)
scores
ncomp = 1
huhn <- suppressWarnings(rARPACK::svds(X, k = ncomp))
huhn$u
huhn$d
huhn <- suppressWarnings(rARPACK::svds(X, k = ncomp))
D <- huhn$d
huhn$u[huhn$u < 1e-10] <- 0
huhn$u
huhn$u[huhn$u < 1e-10] <- 0
scores <- Matrix(
huhn$u %*% diag(D, nrow = ncomp),
sparse = sparse
)
scores
huhn <- suppressWarnings(rARPACK::svds(X, k = ncomp))
D <- huhn$d
huhn$u[huhn$u < 1e-10] <- 0
scores <- Matrix(
huhn$u %*% diag(D, nrow = ncomp),
sparse = sparse
)
huhn$v[huhn$v < 1e-10] <- 0
loadings <- Matrix(
huhn$v,
sparse = sparse
)
scores
loadings
load_all()
getPC(B)
getPC(B, 2, center = F, sparse = T)
getPC(B, 2, center = F, sparse = TRUE)
center = FALSE
!center & sparse
X
attr(X, "scaled:center")
attr(X, "scaled:scale")
X <- scale(X, TRUE, FALSE)
attr(X, "scaled:scale")
Matrix::`%*%`
B
t(B) %*% B
B %*% c(1, 2, 3, 4, 5)
document()
check()
sd
check()
?inherits
foo <- list()
inherits(foo, "list")
?dplyr::arrange
rm(T)
T
A <- matrix(rnorm(20),5)
A
A <- as.data.frame(A)
A %>% arrange()
A %>% arrange(V4)
A %>% dplyr::arrange(V4)
A %>% dplyr::arrange(c(2,1,3,4))
A %>% dplyr::arrange(c(2,1,3,4, 5))
A
document()
check()
